<?php
namespace Dfe\AllPay\Source;
use Dfe\AllPay\Settings as S;
use Magento\Framework\Exception\LocalizedException as LE;
use Magento\Sales\Model\Order as O;
/**
 * 2016-07-17
 * Эта опция задаёт способ идентификации платежа.
 * Наиболее очевидным и удобным способом является использование идентификатора заказа.
 * Однако allPay допускает в идентификаторе платежа (параметре «MerchantTradeNo»)
 * только цифры и латинские буквы:
 * «Merchant trade number».
 * Varchar(20)
 * «Merchant trade number could not be repeated.
 * It is composed with upper and lower cases of English letter and numbers.»
 *
 * В принципе, стандартные номера заказов удовлетворяют этим условиям,
 * но вот нестандартные, вида ORD-2016/07-00274
 * (которые делает наш модуль Sales Documents Numberation) — не удовлетворяют.
 *
 * Поэтому если магазин использует нестандартные номера заказов,
 * то ему для идентификации платежей надо использовать не номера заказов,
 * а автосоздаваемые идентификаторы платежей.
 *
 * @method static PaymentIdentificationType s()
 */
class PaymentIdentificationType extends \Df\Config\SourceT {
	/**
	 * 2016-07-17
	 * @override
	 * @see \Df\Config\Source::map()
	 * @used-by \Df\Config\Source::toOptionArray()
	 * @return array(string => string)
	 */
	protected function map() {return [
		self::$ORDER_IID => 'Order Increment ID'
		,self::$AUTOGENERATED => self::$AUTOGENERATED_V
	];}

	/** @var string */
	private static $AUTOGENERATED = 'autogenerated_random_id';
	/** @var string */
	private static $AUTOGENERATED_V = 'Autogenerated Random ID';
	/** @var string */
	private static $ORDER_IID = 'order_increment_id';

	/**
	 * 2016-07-17
	 * @param O $order
	 * @return string
	 * @throws \Exception|LE
	 */
	public static function id(O $order) {
		/** @var string $result */
		if (self::$AUTOGENERATED === S::s()->paymentIdentificationType()) {
			/**
			 * 2016-08-27
			 * Кэш нужен, чтобы для одного и того же заказа
			 * метод возвращал одно и то же значение.
			 * @var array(string => string) $cache
			 */
			static $cache;
			/** @var string $key */
			$key = $order->getIncrementId();
			if (!isset($cache[$key])) {
				$cache[$key] = df_uid(10);
			}
			$result = $cache[$key];
			df_assert(self::check($result));
		}
		else {
			$result = $order->getIncrementId();
			if (!self::check($result)) {
				df_error(__(
					"«%1» is not allowed as an allPay payment identifier, "
					. "because a valid allPay payment identifier "
					. "should contain only digits and the Latin letters.<br/>"
					. "Please set the «%2» value for the "
					. "«Mage2.PRO» → «Payment» → «歐付寶 allPay» → «Payment Identification Type» "
					. "backend option."
					, $result
					, __(self::$AUTOGENERATED_V)
				));
			}
		}
		return $result;
	}

	/**
	 * 2016-07-17
	 * http://stackoverflow.com/a/9351316
	 * Там решение не совсем верное, я изменил его.
	 * @param string $id
	 * @return bool
	 */
	private static function check($id) {return 1 === preg_match('#^[a-z\d]+$#i', $id);}
}